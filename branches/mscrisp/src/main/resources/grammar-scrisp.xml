<?xml version="1.0" encoding="utf-8"?>

<scrisp-grammar>

  <!-- grammar -->

  <tree id="i.n">
    <leaf cat="n" type="anchor" sem="self" />
  </tree>

  <tree id="a.an">
    <node cat="n" sem="self">
      <leaf cat="a" type="anchor" sem="self"/>
      <leaf cat="n" type="foot" sem="self" />
    </node>
  </tree>

  <tree id="a.p">
    <node cat="np" sem="self">
      <leaf cat="np" type="foot" sem="self"/>
      <node cat="pp" sem="self" >
        <leaf cat="p" type="anchor" sem="self"/>
        <leaf cat="np" type="substitution" sem="npcomp"/>
      </node>
    </node>
  </tree>

  <tree id="i.dn">   <!-- non-xtag --> 
    <node cat="np" sem="self">
      <leaf cat="d" type="anchor" sem="self" />
      <node type="substitution" cat="n" sem="self" />
    </node>
  </tree>

  <tree id="i.transimperative">
    <node cat="s" sem="self">
       <node cat="vp" sem="self">
  	     <leaf cat="v" type="anchor" sem="self"/>
	     <leaf cat="np" type="substitution" sem="obj" />
       </node>
     </node>
  </tree>

<!--
  <tree id="i.intransimperative">
    <node cat="s" sem="self">
       <node cat="vp" sem="self">
  	     <leaf cat="v" type="anchor" sem="self"/>
       </node>
     </node>
  </tree>

  <tree id="a.sentconjunction">
    <node cat="s" sem="self">
      <leaf cat="s" type="foot" sem="self"/>
      <leaf cat="conj" type="anchor" sem="self" />
      <leaf cat="s" type="substitution" sem="other" />
    </node>
  </tree>

  <tree id="i.transppimperative">
    <node cat="s" sem="self">
      <node cat="vp" sem="self">
        <leaf cat="v" type="anchor" sem="self"/>
        <node cat="vp" sem="self">
          <node cat="v" sem="self">
            <leaf cat="" type="terminal" sem="self"/>
          </node>
          <node cat="pp" sem="ppobj">
            <leaf cat="p" type="lex" sem="ppobj"/>
            <leaf cat="np" type="substitution" sem="ppobj"/>
          </node>
        </node>
      </node>
    </node>
  </tree>  

 <tree id="a.sentconjunction2">
    <node cat="s" sem="self">
      <leaf cat="s" type="substitution" sem="other" />
      <leaf cat="conj" type="anchor" sem="self" />
      <leaf cat="s" type="foot" sem="self"/>
    </node>
  </tree>  

  <tree id="i.ditranspp1pp2imperative">
    <node cat="s" sem="self">
      <node cat="vp" sem="self">
        <leaf cat="v" type="anchor" sem="self"/>
        <node cat="vp" sem="self">
          <node cat="v" sem="self">
            <leaf cat="" type="terminal" sem="self"/>
          </node>
          <node cat="pp" sem="ppobj1">
            <leaf cat="p" type="lex" sem="ppobj1"/>
            <leaf cat="np" type="substitution" sem="ppobj1"/>
          </node>
        </node>
        <node cat="vp" sem="self">
          <node cat="v" sem="self">
            <leaf cat="" type="terminal" sem="self"/>
          </node>
          <node cat="pp" sem="ppobj2">
            <leaf cat="p" type="lex" sem="ppobj2"/>
            <leaf cat="np" type="substitution" sem="ppobj2"/>
          </node>
	</node>
      </node>
    </node>
  </tree>
-->  

  <!-- lexicon -->

<!-- 
  <entry word='go_through' pos='v'>
    <tree refid="i.transimperative">
      <pragcond>door(obj)</pragcond> 
      <pragcond>target(obj)</pragcond>
      <impeff>go_through(obj)</impeff>
      <pragcond>player-position(p)</pragcond>
      <pragcond>player-orientation(o)</pragcond>
      <pragcond>object-position(obj,p)</pragcond>
      <param type="positiontype">p</param>
      <param type="orientationtype">o</param>
      <param type="orientationtype">o2</param>
      <param type="orientationtype">o3</param>
    </tree>
  </entry>

  <entry word='go_through' pos='v'>
    <tree refid="i.transimperative">
      <semreq>door(obj)</semreq> 
      <semreq>visible(p,o,obj)</semreq>
      <semreq>target(obj)</semreq>
      <pragcond>player-position(p)</pragcond>
      <pragcond>player-orientation(o)</pragcond>
      <pragcond>object-orientation(obj,o2)</pragcond>
      <pragcond>go-through-compatible(o,o2)</pragcond>
      <impeff>go_through(obj)</impeff>
      <param type="positiontype">p</param>
      <param type="orientationtype">o</param>
      <param type="orientationtype">o2</param>
      <param type="orientationtype">o3</param>
    </tree>
  </entry>
 
  <entry word='take' pos='v'>
    <tree refid="i.transimperative">
      <semreq>trophy(obj)</semreq> 
      <semreq>visible(p,o,obj)</semreq>
      <pragcond>target(obj)</pragcond>
      <pragcond>player-position(p)</pragcond>
      <pragcond>player-orientation(o)</pragcond>
      <impeff>take(obj)</impeff>
      <param type="positiontype">p</param>
      <param type="orientationtype">o</param>
      <param type="orientationtype">o2</param>
      <param type="orientationtype">o3</param>
    </tree>
  </entry>
 
  <entry word='move_one_step' pos='v'>
    <tree refid="i.intransimperative">
      <pragcond>player-position(p1)</pragcond>
      <pragcond>player-orientation(o)</pragcond>
      <pragcond>adjacent(p1,p2,o)</pragcond>
      <pragcond>not(blocked(p1,p2))</pragcond>
      <pragcond>not(alarmed(p2))</pragcond>
      <prageff>not(player-position(p1))</prageff>
      <prageff>player-position(p2)</prageff>
      <impeff>move_one_step()</impeff>
      <param type="positiontype">p1</param>
      <param type="positiontype">p2</param>
      <param type="orientationtype">o</param>
    </tree>
  </entry>

  <entry word='move_two_steps' pos='v'>
    <tree refid="i.intransimperative">
      <pragcond>player-position(p1)</pragcond>
      <pragcond>player-orientation(o)</pragcond>
      <pragcond>adjacent(p1,p2,o)</pragcond>
      <pragcond>not(blocked(p1,p2))</pragcond>
      <pragcond>not(alarmed(p2))</pragcond>
      <pragcond>adjacent(p2,p3,o)</pragcond>
      <pragcond>not(blocked(p2,p3))</pragcond>
      <pragcond>not(alarmed(p3))</pragcond>
      <prageff>not(player-position(p1))</prageff>
      <prageff>player-position(p3)</prageff>
      <impeff>move_two_steps()</impeff>
      <param type="positiontype">p1</param>
      <param type="positiontype">p2</param>
      <param type="positiontype">p3</param>
      <param type="orientationtype">o</param>
    </tree>
  </entry>

  <entry word='move_three_steps' pos='v'>
    <tree refid="i.intransimperative">
      <pragcond>player-position(p1)</pragcond>
      <pragcond>player-orientation(o)</pragcond>
      <pragcond>adjacent(p1,p2,o)</pragcond>
      <pragcond>not(blocked(p1,p2))</pragcond>
      <pragcond>not(alarmed(p2))</pragcond>
      <pragcond>adjacent(p2,p3,o)</pragcond>
      <pragcond>not(blocked(p2,p3))</pragcond>
      <pragcond>not(alarmed(p3))</pragcond>
      <pragcond>adjacent(p3,p4,o)</pragcond>
      <pragcond>not(blocked(p3,p4))</pragcond>
      <pragcond>not(alarmed(p4))</pragcond>
      <prageff>not(player-position(p1))</prageff>
      <prageff>player-position(p4)</prageff>
      <impeff>move_three_steps()</impeff>
      <param type="positiontype">p1</param>
      <param type="positiontype">p2</param>
      <param type="positiontype">p3</param>
      <param type="positiontype">p4</param>
      <param type="orientationtype">o</param>
    </tree>
  </entry>

  <entry word='move_four_steps' pos='v'>
    <tree refid="i.intransimperative">
      <pragcond>player-position(p1)</pragcond>
      <pragcond>player-orientation(o)</pragcond>
      <pragcond>adjacent(p1,p2,o)</pragcond>
      <pragcond>not(blocked(p1,p2))</pragcond>
      <pragcond>not(alarmed(p2))</pragcond>
      <pragcond>adjacent(p2,p3,o)</pragcond>
      <pragcond>not(blocked(p2,p3))</pragcond>
      <pragcond>not(alarmed(p3))</pragcond>
      <pragcond>adjacent(p3,p4,o)</pragcond>
      <pragcond>not(blocked(p3,p4))</pragcond>
      <pragcond>not(alarmed(p4))</pragcond>
      <pragcond>adjacent(p4,p5,o)</pragcond>
      <pragcond>not(blocked(p4,p5))</pragcond>
      <pragcond>not(alarmed(p5))</pragcond>
      <prageff>not(player-position(p1))</prageff>
      <prageff>player-position(p5)</prageff>
      <impeff>move_four_steps()</impeff>
      <param type="positiontype">p1</param>
      <param type="positiontype">p2</param>
      <param type="positiontype">p3</param>
      <param type="positiontype">p4</param>
      <param type="positiontype">p5</param>
      <param type="orientationtype">o</param>
    </tree>
  </entry>

  <entry word='move_five_steps' pos='v'>
    <tree refid="i.intransimperative">
      <pragcond>player-position(p1)</pragcond>
      <pragcond>player-orientation(o)</pragcond>
      <pragcond>adjacent(p1,p2,o)</pragcond>
      <pragcond>not(blocked(p1,p2))</pragcond>
      <pragcond>not(alarmed(p2))</pragcond>
      <pragcond>adjacent(p2,p3,o)</pragcond>
      <pragcond>not(blocked(p2,p3))</pragcond>
      <pragcond>not(alarmed(p3))</pragcond>
      <pragcond>adjacent(p3,p4,o)</pragcond>
      <pragcond>not(blocked(p3,p4))</pragcond>
      <pragcond>not(alarmed(p4))</pragcond>
      <pragcond>adjacent(p4,p5,o)</pragcond>
      <pragcond>not(blocked(p4,p5))</pragcond>
      <pragcond>not(alarmed(p5))</pragcond>
      <pragcond>adjacent(p5,p6,o)</pragcond>
      <pragcond>not(blocked(p5,p6))</pragcond>
      <pragcond>not(alarmed(p6))</pragcond>
      <prageff>not(player-position(p1))</prageff>
      <prageff>player-position(p6)</prageff>
      <impeff>move_five_steps()</impeff>
      <param type="positiontype">p1</param>
      <param type="positiontype">p2</param>
      <param type="positiontype">p3</param>
      <param type="positiontype">p4</param>
      <param type="positiontype">p5</param>
      <param type="positiontype">p6</param>
      <param type="orientationtype">o</param>
    </tree>
  </entry>

  <entry word='turn_left' pos='v'>
    <tree refid="i.intransimperative">
      <pragcond>player-orientation(o1)</pragcond>
      <pragcond>next-orientation-left(o1,o2)</pragcond>
      <prageff>not(player-orientation(o1))</prageff>
      <prageff>player-orientation(o2)</prageff>
      <impeff>turn_left()</impeff>
      <param type="orientationtype">o1</param>
      <param type="orientationtype">o2</param>
    </tree>
  </entry>

  <entry word='turn_right' pos='v'>
    <tree refid="i.intransimperative">
      <pragcond>player-orientation(o1)</pragcond>
      <pragcond>next-orientation-left(o2,o1)</pragcond>
      <prageff>not(player-orientation(o1))</prageff>
      <prageff>player-orientation(o2)</prageff>
      <impeff>turn_right()</impeff>
      <param type="orientationtype">o1</param>
      <param type="orientationtype">o2</param>
    </tree>
  </entry>

  <entry word='turn_around' pos='v'>
    <tree refid="i.intransimperative">
      <pragcond>player-orientation(o1)</pragcond>
      <pragcond>next-orientation-left(o1,o2)</pragcond>
      <pragcond>next-orientation-left(o2,o3)</pragcond>
      <prageff>not(player-orientation(o1))</prageff>
      <prageff>player-orientation(o3)</prageff>
      <impeff>turn_around()</impeff>
      <param type="orientationtype">o1</param>
      <param type="orientationtype">o2</param>
      <param type="orientationtype">o3</param>
    </tree>
  </entry>

  <entry word='and' pos='conj'>
    <tree refid="a.sentconjunction">
      <pragcond>next-referent(self,other)</pragcond>
      <pragcond>conj-node()</pragcond>
      <prageff>not(conj-node())</prageff>
    </tree>
  </entry>   

  <entry word='then' pos='conj'>
    <tree refid="a.sentconjunction">
      <pragcond>next-referent(self,other)</pragcond>
      <pragcond>not(conj-node())</pragcond>
      <prageff>conj-node()</prageff>
    </tree>
  </entry>
 --> 

  <entry word='push' pos='v'>
    <tree refid="i.transimperative">
      <semreq>button(obj)</semreq> 
      <pragcond>target(obj)</pragcond>
      <prageff>adjective-level-zero(id(obj))</prageff>
      <impeff>push(obj)</impeff>
    </tree>
  </entry>
  
  <!--
  <entry word='left' pos='a'>
    <tree refid='a.an'>
      <pragcond>forall(y,not(and(distractor(id(self),y),left-of(y,self))))</pragcond>
      <prageff>forall(y,when(left-of(self,y),not(distractor(id(self),y))))</prageff>
      <pragcond>or(adjective-level-zero(id(self)),adjective-level-one(id(self)))</pragcond>
      <prageff>not(adjective-level-zero(id(self)))</prageff>
      <prageff>not(adjective-level-one(id(self)))</prageff>
      <prageff>adjective-level-two(id(self))</prageff>
      <var>y</var>
    </tree>
  </entry>

  <entry word='right' pos='a'>
    <tree refid='a.an'>
      <pragcond>forall(y,not(and(distractor(id(self),y),left-of(self,y))))</pragcond>
      <prageff>forall(y,when(left-of(y,self),not(distractor(id(self),y))))</prageff>
      <pragcond>or(adjective-level-zero(id(self)),adjective-level-one(id(self)))</pragcond>
      <prageff>not(adjective-level-zero(id(self)))</prageff>
      <prageff>not(adjective-level-one(id(self)))</prageff>
      <prageff>adjective-level-two(id(self))</prageff>
      <var>y</var>
    </tree>
  </entry>

  <entry word='upper' pos='a'>
    <tree refid='a.an'>
      <pragcond>forall(y,not(and(distractor(id(self),y),above(y,self))))</pragcond>
      <prageff>forall(y,when(above(self,y),not(distractor(id(self),y))))</prageff>
      <pragcond>or(adjective-level-zero(id(self)),adjective-level-one(id(self)))</pragcond>
      <prageff>not(adjective-level-zero(id(self)))</prageff>
      <prageff>not(adjective-level-one(id(self)))</prageff>
      <prageff>adjective-level-two(id(self))</prageff>
      <var>y</var>
    </tree>
  </entry>

  <entry word='lower' pos='a'>
    <tree refid='a.an'>
      <pragcond>forall(y,not(and(distractor(id(self),y),above(self,y))))</pragcond>
      <prageff>forall(y,when(above(y,self),not(distractor(id(self),y))))</prageff>
      <pragcond>or(adjective-level-zero(id(self)),adjective-level-one(id(self)))</pragcond>
      <prageff>not(adjective-level-zero(id(self)))</prageff>
      <prageff>not(adjective-level-one(id(self)))</prageff>
      <prageff>adjective-level-two(id(self))</prageff>
      <var>y</var>
    </tree>
  </entry>
 --> 

  <entry word='blue' pos='a'>
    <tree refid='a.an'>
      <semcontent>blue(self)</semcontent>
      <pragcond>adjective-level-zero(id(self))</pragcond>
      <prageff>not(adjective-level-zero(id(self)))</prageff>
      <prageff>not(adjective-level-two(id(self)))</prageff>
      <prageff>adjective-level-one(id(self))</prageff>
      <costclass>absolute</costclass>      
    </tree>
  </entry>

  <entry word='red' pos='a'>
    <tree refid='a.an'>
      <semcontent>red(self)</semcontent>
      <pragcond>adjective-level-zero(id(self))</pragcond>
      <prageff>not(adjective-level-zero(id(self)))</prageff>
      <prageff>not(adjective-level-two(id(self)))</prageff>
      <prageff>adjective-level-one(id(self))</prageff>
      <costclass>absolute</costclass>      
    </tree>
  </entry>

  <entry word='green' pos='a'>
    <tree refid='a.an'>
      <semcontent>green(self)</semcontent>
      <pragcond>adjective-level-zero(id(self))</pragcond>
      <prageff>not(adjective-level-zero(id(self)))</prageff>
      <prageff>not(adjective-level-two(id(self)))</prageff>
      <prageff>adjective-level-one(id(self))</prageff>
      <costclass>absolute</costclass>      
    </tree>
  </entry>

  <entry word='yellow' pos='a'>
    <tree refid='a.an'>
      <semcontent>yellow(self)</semcontent>
      <pragcond>adjective-level-zero(id(self))</pragcond>
      <prageff>not(adjective-level-zero(id(self)))</prageff>
      <prageff>not(adjective-level-two(id(self)))</prageff>
      <prageff>adjective-level-one(id(self))</prageff>
      <costclass>absolute</costclass>      
    </tree>
  </entry>

  <entry word='blue' pos='n'>
    <tree refid='i.n'>
      <semcontent>blue(self)</semcontent>
      <pragcond>adjective-level-zero(id(self))</pragcond>
      <prageff>not(adjective-level-zero(id(self)))</prageff>
      <prageff>not(adjective-level-two(id(self)))</prageff>
      <prageff>adjective-level-one(id(self))</prageff>
      <costclass>absolute</costclass>      
    </tree>
  </entry>

  <entry word='red' pos='n'>
    <tree refid='i.n'>
      <semcontent>red(self)</semcontent>
      <pragcond>adjective-level-zero(id(self))</pragcond>
      <prageff>not(adjective-level-zero(id(self)))</prageff>
      <prageff>not(adjective-level-two(id(self)))</prageff>
      <prageff>adjective-level-one(id(self))</prageff>
      <costclass>absolute</costclass>      
    </tree>
  </entry>

  <entry word='green' pos='n'>
    <tree refid='i.n'>
      <semcontent>green(self)</semcontent>
      <pragcond>adjective-level-zero(id(self))</pragcond>
      <prageff>not(adjective-level-zero(id(self)))</prageff>
      <prageff>not(adjective-level-two(id(self)))</prageff>
      <prageff>adjective-level-one(id(self))</prageff>
      <costclass>absolute</costclass>      
    </tree>
  </entry>

  <entry word='yellow' pos='n'>
    <tree refid='i.n'>
      <semcontent>yellow(self)</semcontent>
      <pragcond>adjective-level-zero(id(self))</pragcond>
      <prageff>not(adjective-level-zero(id(self)))</prageff>
      <prageff>not(adjective-level-two(id(self)))</prageff>
      <prageff>adjective-level-one(id(self))</prageff>
      <costclass>absolute</costclass>      
    </tree>
  </entry>

  <entry word='the' pos='d'>
    <tree refid="i.dn">
    </tree>
  </entry>

<!--
  <entry word='nellipsis' pos='n'>
    <tree refid="i.n">
    </tree>
  </entry>
-->

  <entry word='button' pos='n'>
    <tree refid="i.n">
      <semcontent>button(self)</semcontent>
      <costclass>taxonomic</costclass>      
    </tree>
  </entry>

  <entry word='alarm' pos='n'>
    <tree refid="i.n">
      <semcontent>alarm(self)</semcontent>
    </tree>
  </entry>

  <entry word='door' pos='n'>
    <tree refid="i.n">
      <semcontent>door(self)</semcontent>
    </tree>
  </entry>

<!--
  <entry word='doorway' pos='n'>
    <tree refid="i.n">
      <semcontent>doorway(self)</semcontent>
      <pragcond>door(self)</pragcond>
    </tree>
  </entry>
-->  

  <entry word='safe' pos='n'>
    <tree refid="i.n">
      <semcontent>safe(self)</semcontent>
    </tree>
  </entry>

  <entry word='picture' pos='n'>
    <tree refid="i.n">
      <semcontent>picture(self)</semcontent>
    </tree>
  </entry>

  <entry word='lamp' pos='n'>
    <tree refid="i.n">
      <semcontent>lamp(self)</semcontent>
    </tree>
  </entry>

  <entry word='flower' pos='n'>
    <tree refid="i.n">
      <semcontent>flower(self)</semcontent>
    </tree>
  </entry>

  <entry word='chair' pos='n'>
    <tree refid="i.n">
      <semcontent>chair(self)</semcontent>
    </tree>
  </entry>

  <entry word='trophy' pos='n'>
    <tree refid="i.n">
      <semcontent>trophy(self)</semcontent>
    </tree>
  </entry>

</scrisp-grammar>